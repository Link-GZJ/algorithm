# algorithm
算法学习
## 2023-7-13

### Lc4 二分算法

寻找两个有序数组的中位数，时间复杂度要求log(m+n)。思路：寻找两个有序数组第k(m+n/2)小的数，需要区分奇偶，分别寻找两个数组k/2 -1位置的元素，
若a[k/2 -1] <= b[k/2-1] 则丢掉a[k/2 - 1]及它以前的元素，否则，丢掉b[k/2 -1]及以前的元素，k则减去丢掉的元素，下次只需寻找第（k-丢掉元素个数）
位置的元素。边界情况 注意k/2-1 是否大于数组长度，若大于，则取另外数组k位置的元素即可，k==1时，则比较两个数组的第一个元素，谁更小，谁符合要求返回。

### Lc11 双指针

当a[left] <= a[right]时，抛弃left,left++,因为 area = min(a[left],a[right]) * (right-left);如果抛弃right,则后面的值不会大于area,只有移动较小的一方，
才有可能比上次a[min]大。

### lc15 双指针

首先要数组排序，如果a[i] 和 a[i - 1]相等，直接跳过即可。关键条件 排序， a[first] + a[second] + a[third] = 0; 时间复杂度 O(N`2) 空间复杂度 O(N)

### lc16 双指针
解法与15类似
### lc18 26 27 双指针
解法与15类似

### lc31 下一个排列 双指针
左边i寻找一个较小数，右边i+1需找一个较大数，较小数尽量靠右，较大数尽可能小，则i+1 到n为降序，而后从右边再照一个数>a[i],进行交换，i+1后的序列再进行反转，变为升序


### lc33 旋转数组
这里的关键是不论如何总有一边是有序的

### lc34 二分
两次二分查找即可，第一次遍历左边，遍历一遍即为target第一次出现的位置，相反，遍历右边一遍，即为target最后一次的位置

### lc35 二分
left最后指向的一定是第一个大于等于target的位置

### lc36 有效的数独
问题的关键在每个小九宫格，用所在行/3,所在列/3 即可表示

### lc1991 寻找数组的中心索引
比较简单，遍历数组的每个元素，元素左边之和与元素右边之和相等，即满足条件

### lc56 合并区间
重点先排序，排序之后那么可合并的区间一定是连续的，其次是合并规则，想象两条线如果相交，则第一条线的end >= 第二条线的start

### lc48 矩阵旋转
重点要求不能使用额外的内存，只能进行元素交换，首先可以找到一个公式 a[j][n-1-i] = a[i][j]; 即为a[i][j]旋转后的位置，每次旋转90°，每个元素旋转4次可以回到原点，因此每一轮都可以进行四次元素交换，就这样可以
得到4个交换公式。那些元素需要交换？分为奇偶，偶数为i<n/2,j<n/2.奇数为i<n/2,(实际上为n-1/2,这里便于合并)，j<n+1/2;

### lc 零矩阵
需要两个数组分别记录为0的行和列，再遍历更新即可，空间复杂度为i+j,时间复杂度为i*j

### lc498 对角线遍历
需要找规律，根据对角线遍历，区分奇偶，没太理解

### lc14 最长公共前缀
写了两种，横向扫描和纵向扫描

### lc5 最长回文串